#+TITLE: Pranshu's emacs configuration


# add org shortcuts
* How to install
Just edit the settings.el file

* Information
** Packages to install

None!

** Key bindings


*** Activating other tools
=C-s o= occur =C-c '= in lisp mode to start slime and in message mode
for org =C-x a a= artist mode narrow to region is reccomended =C-x n
e= # narrow to an element =C-x n w= # widen back to the whole page
=C-x * c/q= c for calc and q for quick calc =M-g a= gnus =C-x m= to
send mail =C-x C-j= for dired jump =C-x M-x= toggle line number =f7=
change theme

*** Editing  commands

=M-;= comment -dwim =C-M-o= to split the line =C-/= to undo in region
=M-SPC= for converting a lot of spaces into one space. M-minus-SPC to
replve "\n " with " " =M-l= Lowercase region if selected and if not
upcase word =M-u= same as the previous but with upcase =M-c=
Capitalize word =C-x C-M-t= swap two non overlapping region =C-x SPC=
rectangle region =C-x r t= edit rectangular region =C-x r ?= check
rectangular commands

*** Navigation

=C-M-n= forward-list Move forward over a parenthetical group =C-M-p=
backward-list Move backward over a parenthetical group =C-M-f=
forward-sexp Move forward over a balanced expression =C-M-b=
backward-sexp Move backward over a balanced expression =C-M-k=
kill-sexp Kill balanced expression forward =C-M-SPC= mark-sexp Put the
mark at the end of the sexp.

*** Writing

=C-c M-\= in org mode to htmlize

=C-c 4= flyspell-mode =C-c 5= toggle modeline =C-c 6= center text =C-c
7= visual fill column mode =C-c 8= center text and add flyspell and
remove modeline =C-c 9= turn visusal-fill-column and flyspell off and
add modeline

*** Functions
=M-`= setstuff, current buffer or file being hovered in dired =C-`=
Quicknote =C-M-`= Clear the current setstuff =C-~= Set stuff prompt

=C-x,= add space after comma =C-x /= add question mark before newline

=C-x M-\= indent region or buffer

*** Mail stuff

=M-g a= gnus =C-x m= to send mail


* Code

** Early init
This is full of performance optimizations and major screen changing
operations.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  ;; -*- lexical-binding: t; -*- Pranshu's emacs configuration

  ;; When to activate the garbage cleaner (setq gc-cons-threshold (*
  (setq gc-cons-threshold (* 50 1000 1000))

  ;; Screen changes to make emacs look more minimal (menu-bar-mode -1)
  (toggle-scroll-bar -1)
  (tool-bar-mode -1)
  (set-fringe-mode 33)
  (menu-bar-mode -1)

  ;; thanks to purcell's no-littering package

  (unless (file-directory-p "~/emacs-var/")
    (make-directory "~/emacs-var/"))

  (setq abbrev-file-name                 (concat user-emacs-directory "etc/" "abbrev.el"))
  (setq auto-insert-directory            (concat user-emacs-directory "etc/"  "auto-insert/"))
  (setq auto-save-list-file-prefix       "~/emacs-var/auto-save/sessions/")
  (setq backup-directory-alist           (list (cons "." "~/emacs-var/backup/")))
  (setq bookmark-default-file            "~/emacs-var/bookmark-default.el")
  (setq calc-settings-file               (concat user-emacs-directory "etc/"  "calc-settings.el"))
  (eval-after-load 'desktop
    '(make-directory "~/emacs-var/desktop/" t))
  (setq desktop-dirname                  "~/emacs-var/desktop/")
  (setq desktop-path                     (list desktop-dirname))
  (setq diary-file                       "~/emacs-var/diary")
  (setq ecomplete-database-file          "~/emacs-var/ecomplete-database.el")
  (setq ede-project-placeholder-cache-file "~/emacs-var/ede-projects.el")
  (eval-after-load 'erc
    '(make-directory "~/emacs-var/erc/dcc/" t ))
  (setq erc-dcc-get-default-directory    "~/emacs-var/erc/dcc/")
  (setq erc-log-channels-directory       "~/emacs-var/erc/log-channels/")
  (eval-after-load 'eshell
    '(make-directory (concat user-emacs-directory "etc/"  "eshell/") t))
  (setq eshell-aliases-file              (concat user-emacs-directory "etc/"  "eshell/aliases"))
  (setq eshell-rc-script                 (concat user-emacs-directory "etc/"  "eshell/rc"))
  (setq eshell-login-script              (concat user-emacs-directory "etc/"  "eshell/login"))
  (setq eshell-directory-name            "~/emacs-var/eshell/")
  (setq eudc-options-file                (concat user-emacs-directory "etc/"  "eudc-options.el"))
  (eval-after-load 'eww
    '(make-directory "~/emacs-var/eww/" t))
  (setq eww-bookmarks-directory          "~/emacs-var/eww/")
  (setq filesets-menu-cache-file         "~/emacs-var/filesets-menu-cache.el")
  (setq gamegrid-user-score-file-directory "~/emacs-var/gamegrid-user-score/")
  (eval-after-load 'gnus
    '(make-directory "~/emacs-var/gnus/dribble/" t))
  (setq gnus-dribble-directory           "~/emacs-var/gnus/dribble/")
  (setq gnus-init-file                   (concat user-emacs-directory "etc/"  "gnus/init.el"))
  (setq ido-save-directory-list-file     "~/emacs-var/ido-save-directory-list.el")
  (setq image-dired-db-file              "~/emacs-var/image-dired/db.el")
  (setq image-dired-dir                  "~/emacs-var/image-dired/")
  (setq image-dired-gallery-dir          "~/emacs-var/image-dired/gallery/")
  (setq image-dired-temp-image-file      "~/emacs-var/image-dired/temp-image")
  (setq image-dired-temp-rotate-image-file "~/emacs-var/image-dired/temp-rotate-image")
  (setq kkc-init-file-name               "~/emacs-var/kkc-init.el")
  (setq multisession-directory           "~/emacs-var/multisession/")
  (eval-after-load 'newsticker
    '(make-directory "~/emacs-var/newsticker/" t))
  (setq newsticker-cache-filename        "~/emacs-var/newsticker/cache.el")
  (setq newsticker-dir                   "~/emacs-var/newsticker/data/")
  (setq nsm-settings-file                "~/emacs-var/nsm-settings.el")
  (eval-after-load 'org
    '(make-directory "~/emacs-var/org/" t))
  (setq org-clock-persist-file           "~/emacs-var/org/clock-persist.el")
  (setq org-id-locations-file            "~/emacs-var/org/id-locations.el")
  (setq org-persist-directory            "~/emacs-var/org/persist/")
  (setq org-publish-timestamp-directory  "~/emacs-var/org/timestamps/")
  (setq project-list-file                "~/emacs-var/project-list.el")
  (setq quickurl-url-file                "~/emacs-var/quickurl-url.el")
  (setq rcirc-log-directory              "~/emacs-var/rcirc-log/")
  (setq recentf-save-file                "~/emacs-var/recentf-save.el")
  (setq remember-data-file               "~/emacs-var/remember/data")
  (setq remember-data-directory          "~/emacs-var/remember/data.d/")
  (setq save-place-file                  "~/emacs-var/save-place.el")
  (setq savehist-file                    "~/emacs-var/savehist.el")
  (setq srecode-map-save-file            "~/emacs-var/srecode-map.el")
  (setq semanticdb-default-save-directory "~/emacs-var/semantic/")
  (eval-after-load 'shadowfile
    '(make-directory "~/emacs-var/shadow/" t))
  (setq shadow-info-file                 "~/emacs-var/shadow/info.el")
  (setq shadow-todo-file                 "~/emacs-var/shadow/todo.el")
  (setq shared-game-score-directory      "~/emacs-var/shared-game-score/")
  (setq timeclock-file                   "~/emacs-var/timeclock")
  (setq tramp-auto-save-directory        "~/emacs-var/tramp/auto-save/")
  (setq tramp-persistency-file-name      "~/emacs-var/tramp/persistency.el")
  (setq type-break-file-name             "~/emacs-var/type-break.el")
  (setq url-cache-directory              "~/emacs-var/url/cache/")
  (setq url-configuration-directory      "~/emacs-var/url/")
  (setq url-cookie-file                  "~/emacs-var/url/cookies.el")
  (setq url-history-file                 "~/emacs-var/url/history.el")



#+end_src



** Main path and font information change when changing machines

#+begin_src emacs-lisp :tangle ~/.emacs.d/settings.el
  ;;---------------------------------------------------------------------------
  ;;---------------------------------------------------------------------------

  (setq gnusmailpath "~/GnusMail") ; Where the GnusMail shoud go.
  (add-to-list 'exec-path "C:/stuff/hunspell/bin") ; Spellchecker path only needed for windows
  (setq inferior-lisp-program "sbcl")
  (setq ghc-path (executable-find "ghci"))

  (defvar cassandra-prompt-regexp "^\\(?:\\[[^@]+@[^@]+\\]\\)"
    "Prompt for `run-cassandra'.")
  (setq norm-font "Hack")
  (setq norm-font-height 16)

  (setq send-mail-function 'smtpmail-send-it) (setq
                                               message-send-mail-function 'smtpmail-send-it)
  (setq smtpmail-smtp-server "smtp.autistici.org")
  (setq smtpmail-smtp-service 587)
  (setq message-send-mail-function 'smtpmail-send-it)
  (setq send-mail-function 'smtpmail-send-it)

  (setq mail-sources '((pop :server "mail.autistici.org" :user ""
                            :password "" )))

  (setq user-mail-address "" user-full-name "Pranshu Sharma")
  ;;---------------------------------------------------------------------------
  ;;---------------------------------------------------------------------------

#+end_src

*** If windows is being used

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  ;; if on windows go over this (when (eq system-type 'windows-nt)
  (setq w32-allow-system-shell t)
  (setq ispell-program-name "hunspell")
                                          ;(locate-file "hunspell" exec-path exec-suffixes 'file-executable-p)

  (setq save-interprogram-paste-before-kill 1)

  ;; make PC keyboard's Win key or other to type Super or Hyper, for emacs running on Windows.
  (setq w32-pass-lwindow-to-system nil)
  (setq w32-lwindow-modifier 'super) ; Left Windows key

  (setq w32-pass-rwindow-to-system nil)
  (setq w32-rwindow-modifier 'super) ; Right Windows key

  (setq w32-pass-apps-to-system nil)
  (setq w32-apps-modifier 'hyper) ; Menu/App key
#+end_src


** Options to change

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (if (file-exists-p "~/.emacs.d/settings.elc") (load-file
                                                 "~/.emacs.d/settings.elc")
    (load-file "~/.emacs.d/settings.el"))
#+end_src



** Functions

*** Writing functions



=C-c 4= flyspell-mode =C-c 5= toggle modeline =C-c 6= center text =C-c
7= visual fill column mode =C-c 8= center text and add flyspell and
remove modeline =C-c 9= turn visusal-fill-column and flyspell off and
add modeline

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (global-set-key (kbd "C-c 5") 'flyspell-mode)
  (global-set-key (kbd "C-c 6") 'toggle-mode-line)
  (global-set-key (kbd "C-c 7") 'center-text-toggle)
  (global-set-key (kbd "C-c 8") 'center-text-flyspell)
  (global-set-key (kbd "C-c 9") 'set-colum-to-default)

  (defun toggle-mode-line()
    (interactive)
    (if mode-line-format (setq mode-line-format nil)
      (progn
        (setq mode-line-format (default-value
                                 'mode-line-format))
        (force-mode-line-update) (redraw-display) ) ))

  (defun center-text-toggle() (interactive) (if (car
                                                 (window-margins))
                                                (progn
                                                  (automargin-mode -1)
                                                  (set-window-margins nil nil nil))
                                              (progn
                                                (automargin-mode)
                                                (run-hooks 'window-configuration-change-hook)) ) )

  (defun center-text-flyspell() (interactive) (automargin-mode)
         (flyspell-mode t) (setq mode-line-format nil))

  (defun set-colum-to-default() (interactive) (automargin-mode -1)
         (set-window-margins nil nil nil) (flyspell-mode-off) (setq
                                                               mode-line-format (default-value 'mode-line-format))
         (force-mode-line-update) (redraw-display))

#+end_src

**** Center text

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (defcustom automargin-target-width 98 "width of the margined
      window")


  (define-minor-mode automargin-mode "automatically add margins to
    windows"
    :global nil
    (if automargin-mode (add-hook
                         'window-configuration-change-hook 'automargin-function nil t)
      (remove-hook 'window-configuration-change-hook 'automargin-function
                   t)))

  (defun automargin--window-width (&optional window) (let ((margins
                                                            (window-margins window))
                                                           (width (window-width window)))
                                                       (+ width
                                                          (or (car margins) 0) (or (cdr margins) 0))))


  (defun automargin-function () (interactive) (let*
                                                  ((automargin-margin (/ (- (frame-width) automargin-target-width)
                                                                         2))
                                                   (automargin-margin (if (< automargin-margin 0) 0
                                                                        automargin-margin)))
                                                (dolist (window (window-list)) (let ((margin
                                                                                      (if (= (frame-width) (automargin--window-width window))
                                                                                          automargin-margin 0)))
                                                                                 (set-window-margins window margin
                                                                                                     margin)))))

  ;;(set-window-margins nil nil nil) to reverse

#+end_src

*** Quicknote

Usefull for doing something while writing notes or todos about it or
something.  By pranshu fully.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (setq q-path nil b-name nil)

  (global-set-key [f5] 'eshell-tog) (global-set-key (kbd "M-`")
                                                    'setstuff)
  (global-set-key (kbd "C-`") 'quicknote) (global-set-key
                                           (kbd "C-M-`") #'(lambda () (interactive) (setstuff 1) ))
  (global-set-key (kbd "C-~") #'(lambda () (interactive) (setstuff 2)
                                  ))

  (defun setstuff(&optional clear-stuff) "Setting the path if one is
     not already set or is."  (interactive) (cond ((eq clear-stuff 1)
                                                   (progn (setq q-path nil b-name nil) (message "Cleared.")))
                                                  ((eq
                                                    clear-stuff 2)
                                                   (setq q-path (expand-file-name (read-file-name
                                                                                   "Select file:"))))
                                                  (t (if (eq major-mode 'dired-mode)
                                                         (progn (setq
                                                                 q-path (dired-get-filename))
                                                                (setq b-name nil))
                                                       (progn (setq
                                                               b-name (buffer-name))
                                                              (setq q-path (buffer-file-name)) (if q-path
                                                                                                   (message "Quicknote file set: %S" b-name) (progn (setq b-name nil)
                                                                                                                                                    (message "File must have a path."))))))))

  (defun quicknote() "Opens the file set by (setstuff) in a new window
     with a certin oriantation."
         (interactive) ;; Checking is the window is already open
         (if q-path
             (progn
               (setq b-name
                     (find-file-noselect q-path))
               (if (get-buffer-window b-name)
                   (delete-window (get-buffer-window b-name))
                 (progn ;;If something happen to the buffer
                   (if
                       (or (window-in-direction 'above)
                           (window-in-direction 'below))
                       (split-window-right)
                     (split-window-below))
                   (other-window 1) (switch-to-buffer
                                     b-name))))
           (message "Set the path.")))

#+end_src

*** Expand region

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


  (defun select-symbol()
    "Selects the current symbol"
    (interactive)
    (skip-syntax-forward "'")
    (skip-syntax-forward "_w")
    (push-mark (point) t t)
    (skip-syntax-backward "_w")
    (skip-syntax-backward "'"))

  (defun select-string()
    "Selecting inside a string including the string itself"
    (interactive)
    (goto-char (nth 8 (syntax-ppss)))
    (set-mark (point))
    (forward-sexp)
    )

  ;; to check if point is on the paren
  ;; (looking-at "\\s(")
  ;; (looking-at "\\s)")

  (defun looking-at-forward-paren()
    (interactive)
    (set-mark (point))
    (forward-list))

  (defun looking-at-backward-paren()
    (interactive)
    (set-mark (point))
    (forward-char)
    (backward-list))

  (defun highlight-paren-block()
    (interactive)
    (goto-char (nth 1 (syntax-ppss)))
    (set-mark (point))
    (forward-list)
    )

  (defun highlight-paren-block()
    (interactive)
    (goto-char (nth 1 (syntax-ppss)))
    (set-mark (point))
    (forward-list)
    )

  (defun expand-selection()
    (interactive)
    (if (use-region-p)
        (if (nth 3 (syntax-ppss))  
            (select-string)
          (when (> (car (syntax-ppss)) 0)
            (highlight-paren-block)))
      (cond
       ((looking-at "\\s(")
        (looking-at-forward-paren))
       ((looking-at "\\s)")
        (looking-at-backward-paren))
       ((or
         (looking-at "\\s_\\|\\sw")
         (looking-back "\\s_\\|\\sw" (line-beginning-position)))
        (select-symbol))
       ((nth 3 (syntax-ppss))
        (select-string))
       ((> (car (syntax-ppss)) 0)
        (highlight-paren-block)))))


  ;; If inside quotes (nth 3 (syntax-ppss))
  ;; to check if point is inside pairs ( (car (syntax-ppss)) 0)



#+end_src

*** xah-add-space-after-comma

Credits to Xah Lee

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (global-set-key (kbd "\C-x,") 'xah-add-space-after-comma)

  (defun xah-add-space-after-comma ()
    "Add a space after comma of current block or selection.
    and highlight changes it made.
    Version 2022-01-20"
    (interactive)
    (let ($p1 $p2)
      (if (region-active-p)
          (progn
            (setq $p1 (region-beginning) $p2 (region-end)))
        (progn
          (save-excursion
            (if (re-search-backward "\n[ \t]*\n" nil "move")
                (progn (re-search-forward "\n[ \t]*\n")
                       (setq $p1 (point)))
              (setq $p1 (point)))
            (if (re-search-forward "\n[ \t]*\n" nil "move")
                (progn (re-search-backward "\n[ \t]*\n")
                       (setq $p2 (point)))
              (setq $p2 (point))))))
      (save-restriction
        (narrow-to-region $p1 $p2)
        (goto-char (point-min))
        (while
            (re-search-forward ",\\b" nil t)
          (replace-match ", ")))))
#+end_src

*** Question mark after end of line in block

Modifed version of xah-add-space-after-comma

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (global-set-key (kbd "\C-x/") 'add-question-before-newline )

  (defun add-question-before-newline ()
    "Replaces the newline charcter with
         the ?\n"
    (interactive)
    (let ($p1 $p2)
      (if (region-active-p)
          (progn
            (setq $p1 (region-beginning) $p2 (region-end)))
        (progn
          (save-excursion
            (if (re-search-backward "\n[ \t]*\n" nil "move")
                (progn (re-search-forward "\n[ \t]*\n")
                       (setq $p1 (point)))
              (setq $p1 (point)))
            (if (re-search-forward "\n[ \t]*\n" nil "move")
                (progn (re-search-backward "\n[ \t]*\n")
                       (setq $p2 (point)))
              (setq $p2 (point))))
          (when (< $p2 (point-max))
            (setq $p2 (+ $p2 1)))))
      (save-restriction
        (narrow-to-region $p1 $p2)
        (goto-char (point-min))
        (while
            (re-search-forward "\n" nil t)
          (replace-match "?\n")))))

#+end_src

*** Indent region or buffer

From emacs redux

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  
  (global-set-key (kbd "C-x M-\\") 'er-indent-region-or-buffer)

  (defun er-indent-region-or-buffer ()
    "Indent a region if selected, otherwise the whole buffer."
    (interactive)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (indent-region (point-min) (point-max))
          (message "Indented buffer.")))))

#+end_src

*** Toggle line numbers

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (global-set-key (kbd "C-x M-x") 'toggle-line-numbers)

  (defun toggle-line-numbers ()
    (interactive)
    (if (bound-and-true-p display-line-numbers-mode)
        (progn
          (set-window-fringes (selected-window) 33 0)
          (display-line-numbers-mode -1)
          (remove-hook 'prog-mode-hook 'display-line-numbers-mode))
      (progn
        (set-window-fringes (selected-window) 15 0)
        (display-line-numbers-mode 1)
        (add-hook 'prog-mode-hook 'display-line-numbers-mode))))

#+end_src


** Emacs settings

*** Font nonsense

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (set-face-attribute 'fixed-pitch nil :font (format "%s-%d" norm-font norm-font-height))

  (set-face-attribute 'default nil :font (format "%s-%d" norm-font norm-font-height))
#+end_src

*** History insecurities

I do not like the idea of things that have the potential to grow infinitively in a finite world.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (setq undo-limit 800000) ; the undo limit

  (setq eshell-save-history-on-exit nil) ; why not

  (setq eshell-buffer-maximum-lines 512) ; to save the 

#+end_src

*** Changing emacs behavior

Some default features in emacs that I find annoying and enabling some that are good
for my use case.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (defalias 'yes-or-no-p 'y-or-n-p) ;; y and n instead of yes and no

  (auto-save-mode -1) ; annoying popus

  (setq auto-save-default nil) ; The auto save #xyz# files

  (setq make-backup-files nil)

  (global-auto-revert-mode 1) ; If code is changed by an other application

  (global-visual-line-mode)

  (delete-selection-mode 1) ; overwriting the current region when typing in one.

  (global-so-long-mode 1)



#+end_src

*** Indentaton

I prefer tabs, but emacs uses a mix of tabs as spaces which is a worse then spaces.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (setq-default tab-always-indent t) ; got hippie expand for completion
  (setq-default tab-first-completion 'word-or-paren-or-punct)
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil)

#+end_src

*** Whitespace control

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (add-hook 'before-save-hook 'clean-when-prog)
  (defun clean-when-prog ()(when (derived-mode-p 'prog-mode)
                             (whitespace-cleanup)))

#+end_src

*** utf, large file

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (set-default-coding-systems 'utf-8)
  (setq visible-bell 1)
  (setq large-file-warning-threshold 100000000)
#+end_src


** Themeing

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


  (require-theme 'modus-themes)


  (setq modus-themes-intense-mouseovers nil)
  (setq  modus-themes-mode-line '(borderless))
  (setq  modus-themes-subtle-line-numbers t)
  (setq  modus-themes-links '(neutral-underline))
  (setq  modus-themes-region '(bg-only no-extend))
  (setq  modus-themes-org-agenda
         '((header-block . (variable-pitch light 1.6))
           (header-date . (underline-today grayscale workaholic 1.2))
           (event . (accented italic varied))
           (scheduled . rainbow)
           (habit . simplified)))
  (setq  modus-themes-headings
         '((0 . (variable-pitch monochrome light (height 2.2)))
           (1 . (variable-pitch light (height 1.6)))
           (2 . (variable-pitch light (height 1.4)))
           (3 . (variable-pitch regular (height 1.3)))
           (4 . (rainbow regular (height 1.2)))
           (5 . (rainbow (height 1.1)))
           (t . (variable-pitch rainbow extrabold)))
         )



  (modus-themes-load-themes)
  (modus-themes-load-vivendi)

  (global-set-key [f7]  'modus-themes-toggle)


#+end_src


** Tools

*** Programming modes

**** Lisp mode

Good old inf lisp.

C-c q to compile current defun

C-c e lisp-eval-defun-and-go
C-c r lisp-eval-region-and-go
C-c c lisp-compile-defun-and-go
C-c z switch-to-lisp
C-c l lisp-load-file
C-c k lisp-compile-file
C-c a lisp-show-arglist
C-c d lisp-describe-sym
C-c f lisp-show-function-documentation
C-c v lisp-show-variable-documentation
inferior-lisp-mode-map "\C-cl" #'lisp-load-file
inferior-lisp-mode-map "\C-ck" #'lisp-compile-file
inferior-lisp-mode-map "\C-ca" #'lisp-show-arglist


#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (define-key lisp-mode-map (kbd "C-c '") 'run-lisp) ; open inf lisp in slimde minor mode

  (setq inferior-lisp-prompt "^\\(->\\|<[0-9]*>:\\) *")
  (require 'inf-lisp)
                                          ; (defun pranshu-inferior-lisp-install-letter-bindings ()
  (define-key lisp-mode-map "\C-ce" #'lisp-eval-defun-and-go)
  (define-key lisp-mode-map "\C-cr" #'lisp-eval-region-and-go)
  (define-key lisp-mode-map "\C-cq" #'lisp-compile-defun-and-go)
  (define-key lisp-mode-map "\C-cz" #'switch-to-lisp)
  (define-key lisp-mode-map "\C-cl" #'lisp-load-file)
  (define-key lisp-mode-map "\C-ck" #'lisp-compile-file)
  (define-key lisp-mode-map "\C-ca" #'lisp-show-arglist)
  (define-key lisp-mode-map "\C-cd" #'lisp-describe-sym)
  (define-key inferior-lisp-mode-map "\C-cl" #'lisp-load-file)
  (define-key inferior-lisp-mode-map "\C-ck" #'lisp-compile-file)
  (define-key inferior-lisp-mode-map "\C-ca" #'lisp-show-arglist);)


#+end_src

**** todo haskell

***** todo comments; syntax coloring 

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


  ;; impossible without th eknowledge from haskell-mode

  (defun haskell-font-lock-keywords ()
    ;; this has to be a function because it depends on global value of
    ;; `haskell-font-lock-symbols'
    "Generate font lock eywords."
    (let* (;; Bird-style literate scripts start a line of code with
           ;; "^>", otherwise a line of code starts with "^".
           (varid "[[:lower:]_][[:alnum:]'_]*")
           ;; We allow ' preceding conids because of DataKinds/PolyKinds
           (conid "'?[[:upper:]][[:alnum:]'_]*")
           (sym "\\s.+")
           ;; Top-level declarations
           (topdecl-var
            (concat "^\\(?:> ?\\)?" "\\(" varid "\\(?:\\s-*,\\s-*" varid "\\)*" "\\)"
                    ;; optionally allow for a single newline after identifier
                    "\\(\\s-+\\|\\s-*[\n]\\s-+\\)"
                    ;; A toplevel declaration can be followed by a definition
                    ;; (=), a type (::) or (∷), a guard, or a pattern which can
                    ;; either be a variable, a constructor, a parenthesized
                    ;; thingy, or an integer or a string.
                    "\\(" varid "\\|" conid "\\|::\\|∷\\|=\\||\\|\\s(\\|[0-9\"']\\)"))
           (topdecl-var2
            (concat "^\\(?:> ?\\)?" "\\(" varid "\\|" conid "\\)\\s-*`\\(" varid "\\)`"))
           (topdecl-bangpat
            (concat "^\\(?:> ?\\)?" "\\(" varid "\\)\\s-*!"))
           (topdecl-sym
            (concat "^\\(?:> ?\\)?" "\\(" varid "\\|" conid "\\)\\s-*\\(" sym "\\)"))

                                          ;keywords
           )

      (setq keywords
            `(
              ("^#\\(?:[^\\\n]\\|\\\\\\(?:.\\|\n\\|\\'\\)\\)*\\(?:\n\\|\\'\\)" 0 'font-lock-preprocessor-face t)

              ;; Special case for `as', `hiding', `safe' and `qualified', which are
              ;; keywords in import statements but are not otherwise reserved.
              ("\\<import[ \t]+\\(?:\\(safe\\>\\)[ \t]*\\)?\\(?:\\(qualified\\>\\)[ \t]*\\)?\\(?:\"[^\"]*\"[\t ]*\\)?[^ \t\n()]+[ \t]*\\(?:\\(qualified\\>\\)[ \t]*\\)?\\(?:\\(\\<as\\>\\)[ \t]*[^ \t\n()]+[ \t]*\\)?\\(\\<hiding\\>\\)?"
               (1 'font-lock-keyword-face nil lax)
               (2 'font-lock-keyword-face nil lax)
               (3 'font-lock-keyword-face nil lax)
               (4 'font-lock-keyword-face nil lax)
               (5 'font-lock-keyword-face nil lax))

              ;; Special case for `foreign import'
              ;; keywords in foreign import statements but are not otherwise reserved.
              ("\\<\\(foreign\\)[ \t]+\\(import\\)[ \t]+\\(?:\\(ccall\\|capi\\|stdcall\\|cplusplus\\|jvm\\|dotnet\\)[ \t]+\\)?\\(?:\\(safe\\|unsafe\\|interruptible\\)[ \t]+\\)?"
               (1 'font-lock-keyword-face nil lax)
               (2 'font-lock-keyword-face nil lax)
               (3 'font-lock-keyword-face nil lax)
               (4 'font-lock-keyword-face nil lax))

              ;; Special case for `foreign export'
              ;; keywords in foreign export statements but are not otherwise reserved.
              ("\\<\\(foreign\\)[ \t]+\\(export\\)[ \t]+\\(?:\\(ccall\\|stdcall\\|cplusplus\\|jvm\\|dotnet\\)[ \t]+\\)?"
               (1 'font-lock-keyword-face nil lax)
               (2 'font-lock-keyword-face nil lax)
               (3 'font-lock-keyword-face nil lax))

              ;; Special case for `type family' and `data family'.
              ;; `family' is only reserved in these contexts.
              ("\\<\\(type\\|data\\)[ \t]+\\(family\\>\\)"
               (1 'font-lock-keyword-face nil lax)
               (2 'font-lock-keyword-face nil lax))

              ;; Special case for `type role'
              ;; `role' is only reserved in this context.
              ("\\<\\(type\\)[ \t]+\\(role\\>\\)"
               (1 'font-lock-keyword-face nil lax)
               (2 'font-lock-keyword-face nil lax))

              ;; Toplevel Declarations.
              ;; Place them *before* generic id-and-op highlighting.
              (,topdecl-var  (1 (unless (member (match-string 1) haskell-font-lock-keywords)
                                  'font-lock-function-name-face)))
              (,topdecl-var2 (2 (unless (member (match-string 2) haskell-font-lock-keywords)
                                  'font-lock-function-name-face)))
              (,topdecl-bangpat  (1 (unless (member (match-string 1) haskell-font-lock-keywords)
                                      'font-lock-function-name-face)))
              (,topdecl-sym  (2 (unless (member (match-string 2) '("\\" "=" "->" "→" "<-" "←" "::" "∷" "," ";" "`"))
                                  'font-lock-function-name-face)))


              ;; These four are debatable...
              ("(\\(,*\\|->\\))" 0 'font-lock-type-face)
              ("\\[\\]" 0 'font-lock-type-face)

              )))
    keywords)

  (defun haskell-syntactic-face-function (state)
    "`font-lock-syntactic-face-function' for Haskell."
    (cond
     ((nth 3 state)
      (if (equal ?| (nth 3 state))
          ;; find out what kind of QuasiQuote is this
          (let* ((qqname (save-excursion
                           (goto-char (nth 8 state))
                           (skip-syntax-backward "w._")
                           (buffer-substring-no-properties (point) (nth 8 state))))
                 (lang-mode (cdr (assoc (haskell-string-drop-qualifier qqname)
                                        haskell-font-lock-quasi-quote-modes))))

            (if (and lang-mode
                     (fboundp lang-mode))
                (save-excursion
                  ;; find the end of the QuasiQuote
                  (parse-partial-sexp (point) (point-max) nil nil state
                                      'syntax-table)
                  (haskell-font-lock-fontify-block lang-mode (1+ (nth 8 state)) (1- (point)))
                  ;; must return nil here so that it is not fontified again as string
                  nil)
              ;; fontify normally as string because lang-mode is not present
              'haskell-quasi-quote-face))
        (save-excursion
          (let
              ((state2
                (parse-partial-sexp (point) (point-max) nil nil state
                                    'syntax-table))
               (end-of-string (point)))

            (put-text-property (nth 8 state) (point)
                               'face 'font-lock-string-face)


            (if (or (equal t (nth 3 state)) (nth 3 state2))
                ;; This is an unterminated string constant, use warning
                ;; face for the opening quote.
                (put-text-property (nth 8 state) (1+ (nth 8 state))
                                   'face 'font-lock-warning-face))

            (goto-char (1+ (nth 8 state)))
            (while (re-search-forward "\\\\" end-of-string t)

              (goto-char (1- (point)))

              (if (looking-at haskell-lexeme-string-literal-inside-item)
                  (goto-char (match-end 0))

                ;; We are looking at an unacceptable escape
                ;; sequence. Use warning face to highlight that.
                (put-text-property (point) (1+ (point))
                                   'face 'font-lock-warning-face)
                (goto-char (1+ (point)))))))
        ;; must return nil here so that it is not fontified again as string
        nil))
     ;; Detect literate comment lines starting with syntax class '<'
     ((save-excursion
        (goto-char (nth 8 state))
        (equal (string-to-syntax "<") (syntax-after (point))))
      'haskell-literate-comment-face)
     ;; Detect pragmas. A pragma is enclosed in special comment
     ;; delimiters {-# .. #-}.
     ((save-excursion
        (goto-char (nth 8 state))
        (and (looking-at-p "{-#")
             (forward-comment 1)
             (goto-char (- (point) 3))
             (looking-at-p "#-}")))
      'haskell-pragma-face)
     ;; Detect Liquid Haskell annotations enclosed in special comment
     ;; delimiters {-@ .. @-}.
     ((save-excursion
        (goto-char (nth 8 state))
        (and (looking-at-p "{-@")
             (forward-comment 1)
             (goto-char (- (point) 3))
             (looking-at-p "@-}")))
      'haskell-liquid-haskell-annotation-face)
     ;; Haddock comment start with either "-- [|^*$]" or "{- ?[|^*$]"
     ;; (note space optional for nested comments and mandatory for
     ;; double dash comments).
     ;;
     ;; Haddock comment will also continue on next line, provided:
     ;; - current line is a double dash haddock comment
     ;; - next line is also double dash comment
     ;; - there is only whitespace between
     ;;
     ;; We recognize double dash haddock comments by property
     ;; 'font-lock-doc-face attached to newline. In case of {- -}
     ;; comments newline is outside of comment.
     ((save-excursion
        (goto-char (nth 8 state))
        (or (looking-at-p "\\(?:{- ?\\|-- \\)[|^*$]")
            (and (looking-at-p "--")            ; are we at double dash comment
                 (forward-line -1)              ; this is nil on first line
                 (eq (get-text-property (line-end-position) 'face)
                     'font-lock-doc-face)       ; is a doc face
                 (forward-line)
                 (skip-syntax-forward "-")      ; see if there is only whitespace
                 (eq (point) (nth 8 state)))))  ; we are back in position
      ;; Here we look inside the comment to see if there are substrings
      ;; worth marking inside we try to emulate as much of haddock as
      ;; possible.  First we add comment face all over the comment, then
      ;; we add special features.
      (let ((beg (nth 8 state))
            (end (save-excursion
                   (parse-partial-sexp (point) (point-max) nil nil state
                                       'syntax-table)
                   (point)))
            (emphasis-open-point nil)
            (strong-open-point nil))
        (put-text-property beg end 'face 'font-lock-doc-face)

        (when (fboundp 'add-face-text-property)
          ;; `add-face-text-property' is not defined in Emacs 23

          ;; iterate over chars, take escaped chars unconditionally
          ;; mark when a construct is opened, close and face it when
          ;; it is closed

          (save-excursion
            (while (< (point) end)
              (if (looking-at "__\\|\\\\.\\|\\\n\\|[/]")
                  (progn
                    (cond
                     ((equal (match-string 0) "/")
                      (if emphasis-open-point
                          (progn
                            (add-face-text-property emphasis-open-point (match-end 0)
                                                    '(:slant italic))
                            (setq emphasis-open-point nil))
                        (setq emphasis-open-point (point))))
                     ((equal (match-string 0) "__")
                      (if strong-open-point
                          (progn
                            (add-face-text-property strong-open-point (match-end 0)
                                                    '(:weight bold))
                            (setq strong-open-point nil))
                        (setq strong-open-point (point))))
                     (t
                      ;; this is a backslash escape sequence, skip over it
                      ))
                    (goto-char (match-end 0)))
                ;; skip chars that are not interesting
                (goto-char (1+ (point)))
                (skip-chars-forward "^_\\\\/" end))))))
      nil)
     (t 'font-lock-comment-face)))

  (defcustom haskell-font-lock-keywords
    '("case" "class" "data" "default" "deriving" "do"
      "else" "if" "import" "in" "infix" "infixl"
      "infixr" "instance" "let" "module" "mdo" "newtype" "of"
      "rec" "pattern" "proc" "signature" "then" "type" "where" "_" "anyclass" "stock" "via")
    "Identifiers treated as reserved keywords in Haskell."
    :type '(repeat string))


  (define-derived-mode pranshu-haskell prog-mode "hs-mode"
    (setq-local  font-lock-defaults
                 '((haskell-font-lock-keywords)
                   nil nil nil nilx
                   (font-lock-syntactic-face-function
                    . haskell-syntactic-face-function)
                   ;; Get help from font-lock-syntactic-keywords.
                   (parse-sexp-lookup-properties . t)
                   (font-lock-extra-managed-props . (composition))))
    (setq-local comment-start "--")
    (font-lock-add-keywords nil '(("--.+" . font-lock-comment-face)))
    )




#+end_src

***** todo automaticly load current file interactive

https://www.masteringemacs.org/article/comint-writing-command-interpreter

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

                                          ;ghc-path is name of var

  (defun run-haskell ()
    "Run an inferior instance of `haskell' inside Emacs."
    (interactive)
    (let* ((ghc-program ghc-path)
           (buffer (comint-check-proc "Haskell")))
      ;; pop to the "*Cassandra*" buffer if the process is dead, the
      ;; buffer is missing or it's got the wrong mode.
      (pop-to-buffer-same-window
       (if (or buffer (not (derived-mode-p 'pranshu-haskell)) ; todo replace this with the haskell colour mode
               (comint-check-proc (current-buffer)))
           (get-buffer-create (or buffer "*Haskell*"))
         (current-buffer)))
      ;; create the comint process if there is no buffer.
      (unless buffer
        (apply 'make-comint-in-buffer "Haskell" buffer
               ghc-program  ;ghc-command-arguments
               (when (string-match ".hs$" buffer-file-name)
                 `(,buffer-file-name))
               )
                                          ; (pranshu-haskell ) ; make haskell mode
        )
      (switch-to-buffer "*Haskell*")))

  (define-key pranshu-haskell-map (kbd "C-c '") 'run-haskell)

  (add-to-list 'auto-mode-alist '("\\.hs\\'" . pranshu-haskell))

#+end_src

***** todo indent


#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (defcustom haskell-indent-offset 4
    " "
    :type 'integer
    :safe #'natnump)

  
  (defconst haskell-indent-start-keywords-re
    (concat "\\<"
            (regexp-opt '("class" "data" "import" "infix" "infixl" "infixr"
                          "instance" "module" "newtype" "primitive" "signature" "type") t)
            "\\>")
    "Regexp for keywords to complete when standing at the first word of a line.")


#+end_src


**** todo python

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


  ;; (require 'python)
  ;; (define-key python-mode-map (kbd "C-c '") 'run-python)
  ;; (setq python-indent-guess-indent-offset t)  

#+end_src


*** Dired

The emacs file manager. I use ls-lisp instead of the systems ls for consitancy across multiple systems.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (require 'dired)
  (require 'ls-lisp)

  (setq ls-lisp-dirs-first t) ; directories first
  (setq ls-lisp-use-insert-directory-program nil) ; do it your self you baffon
  (setq dired-dwim-target t) ; with two dired windows open
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)

  (setq delete-by-moving-to-trash t) ; thinking about what you are doing; hell nah


  (defun dired-mode-setup ()
    "hook for dired mode"
    (dired-hide-details-mode 1))
  (add-hook 'dired-mode-hook 'dired-mode-setup) ; details are distracting

#+end_src

*** Imenu

Works in most modes and is really a life saver

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (global-set-key (kbd "C-'") 'imenu)

#+end_src

*** Flyspell

I use hunspell because flyspell does not work in windows

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (require 'flyspell)
  (require 'ispell)
  (setq flyspell-issue-message-flag nil)
  (define-key flyspell-mode-map [down-mouse-3] 'flyspell-correct-word)
  (global-set-key (kbd "M-\\") 'ispell-word)
  (setq  ispell-dictionary "english")
  (setq   spell-local-dictionary-alist
          '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))

                                          ;(("en_US" ,(concat user-emacs-directory "en_US.aff" )))

#+end_src

*** Bracket tools

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (add-hook 'prog-mode-hook #'electric-pair-mode)

#+end_src

*** Eshell

A prompt with only the previous directory and some aliases.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (setq eshell-prompt-function
        (lambda ()
          (concat (car (last (split-string (eshell/pwd) "/"))) " $ ")))

  (defalias 'open 'find-file)
  (defalias 'gs 'magit-status-here)
  (defalias 'd 'dired)
  (defalias 'openo 'find-file-other-window)

  (with-eval-after-load 'eshell  '(lambda()         
                                    (add-to-list 'eshell-output-filter-functions #'eshell-truncate-buffer)))

#+end_src


**** Eshell toggle

Once upon a time there was a toggle eshell package and it was 300 lines of code and it
basically remade functions emacs already has.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


  (setq eshell-config-done nil)

  (defun eshell-tog()
    "Popups the eshell if one is not already open, will create if it has to"
    (interactive)
    (let ((temp-default-directory nil))
      (if(get-buffer "*eshell*")
          (if (get-buffer-window "*eshell*")
              (delete-window (get-buffer-window "*eshell*"))
            (progn
              (split-window-below)
              (other-window 1)
              (setq temp-default-directory default-directory) 
              (switch-to-buffer "*eshell*")
              (cd temp-default-directory)
              (insert "#")
              (eshell-send-input)
              ))
        (progn
          (split-window-below)
          (setq temp-default-directory default-directory)
          (other-window 1)
          (eshell)
          (message "New eshell buffer.")
          (cd temp-default-directory)          
          ))))



#+end_src

*** Artist mode

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (setq rem-mode-name nil)

  (defun rem-mode()
    (interactive)
    (if rem-mode-name
        (progn (eval `(,rem-mode-name))
               (setq rem-mode-name nil))
      (setq rem-mode-name major-mode)
      ))

  (with-eval-after-load 'inf-lisp 'inferior-lisp-install-letter-bindings)
  (global-set-key (kbd "C-x a r") #'rem-mode)
  (global-set-key (kbd "C-x a a") #'(lambda()
                                      (interactive)
                                      (rem-mode)
                                      (artist-mode)))

#+end_src


** completion and isearch

Used to use Ido then vertico then ido again and then vertico and now fido and icomplete. Hippe expand started expanding blocks which is unacceptable.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


  (setq icomplete-max-delay-chars 0)
  (setq icomplete-compute-delay 0)
  (setq icomplete-prospects-height 1)
  (setq completion-flex-nospace nil)
  (fido-vertical-mode 1)

  ;; hippie expand
  (global-set-key (kbd "M-/") 'hippie-expand)
  (setq hippie-expand-try-functions-list ;; in case of new featueres
        '(
          try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-expand-dabbrev-from-kill
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol
          try-complete-file-name-partially
          try-complete-file-name
          try-expand-all-abbrevs
          try-expand-list
          try-expand-line
          ))
  (global-set-key (kbd "M-/") 'hippie-expand)

#+end_src




** networking

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (require 'gnus)

  (defun tog-message-mode()
    (interactive)
    (if (eq major-mode 'org-mode)
        (message-mode)
      (org-mode)))

  (global-set-key (kbd "M-g a") 'gnus)
  (global-set-key (kbd "M-g w") 'eww)
  ;;M-enter to open in a new buffer

  (add-hook 'message-mode-hook #'(lambda ()
                                   (flyspell-mode t)))
  (setq gnus-select-method '(nntp "news.gnus.org"))
  (add-to-list 'gnus-secondary-select-methods
               `(nnml ""
                      (nnml-directory ,gnusmailpath)
                      (nnml-active-file ,(concat gnusmailpath "/active") )))


  (setq gnus-use-article-prefetch 15)
  (setq gnus-asynchronous t)

  (setq gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject)


#+end_src


** Buffer cleaning and window managment

*** Window mangment

Navigation the windows. =C-x o= is cool and all with 2 buffers but
with 3 or more a better solution is needed. Ace-window is to
complicated so windmove works. Golden raio is convinent but the movment distracts and the extra movment makes me loose focus

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (setq display-buffer-alist
        `(;; no window
          ("\\`\\*Async Shell Command\\*\\'"
           (display-buffer-no-window))
          ;; top side window
          ((derived-mode . messages-buffer-mode)
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1))

          ((or . ((derived-mode . backtrace-mode)
                  "\\*\\(Warnings\\|Compile-Log\\)\\*"))
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2))))


  (global-set-key (kbd "C-x ]") #'(lambda()(interactive)
                                    (enlarge-window-horizontally 8)))

  (global-set-key (kbd "C-x [") #'(lambda()(interactive)
                                    (shrink-window-horizontally 8)))

  (global-set-key (kbd "s-]") 'next-buffer)
  (global-set-key (kbd "s-[") 'previous-buffer)
  (global-set-key (kbd "C-<up>") #'windmove-up)
  (global-set-key (kbd "C-<right>") #'windmove-right)
  (global-set-key (kbd "C-<down>") #'windmove-down)
  (global-set-key (kbd "C-<left>") #'windmove-left)
  (global-set-key (kbd "C-M-<up>") #'windmove-swap-states-up)
  (global-set-key (kbd "C-M-<right>") #'windmove-swap-states-right)
  (global-set-key (kbd "M-]") #'other-window)


#+end_src

*** Buffer cleaning

Just for peace of mind

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (require 'midnight)
  (global-set-key (kbd "C-x c") 'clean-buffer-list)
  (setq clean-buffer-list-delay-general 1)
  (setq midnight-period 7200)
  (midnight-delay-set 'midnight-delay 1)
  (setq midnight-mode t)
  (define-key global-map (kbd "C-x C-b") 'ibuffer)


#+end_src




*** Narrowing to region

I find this sometimes helpful

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (put 'narrow-to-page 'disabled nil)

  (put 'narrow-to-region 'disabled nil)

#+end_src


** cusrory, expand region and keybindings 


*** Cursory


#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


  (setq blink-cursor-mode nil)

  (setq pulse-delay 0.07)

  (tooltip-mode -1)

  (defface pulse-magenta
    '((t :inherit pulse-highlight-start-face :extend t)
      (((class color) (min-colors 88) (background light))
       :background "#ffccff")
      (((class color) (min-colors 88) (background dark))
       :background "#71206a")
      (t :inverse-video t))
    "Alternative magenta face for `pulsar-face'.")


  (defcustom pulse-functions
    '(recenter-top-bottom
      move-to-window-line-top-bottom
      reposition-window
      bookmark-jump
      other-window
      delete-window
      delete-other-windows
      forward-page
      backward-page
      scroll-up-command
      scroll-down-command
      windmove-right
      windmove-left
      windmove-up
      windmove-down
      windmove-swap-states-right
      windmove-swap-states-left
      windmove-swap-states-up
      windmove-swap-states-down
      tab-new
      tab-close
      tab-next
      org-next-visible-heading
      org-previous-visible-heading
      org-forward-heading-same-level
      org-backward-heading-same-level
      outline-backward-same-level
      outline-forward-same-level
      outline-next-visible-heading
      outline-previous-visible-heading
      outline-up-heading
      occu)
    "Functions that `pulsar-pulse-line' after invocation.
                This only takes effect when `pulsar-mode' (buffer-local) or
                `pulsar-global-mode' is enabled."
    :type '(repeat function))

  (defun pulse-line()
    (interactive)
    (pulse-momentary-highlight-one-line nil 'pulse-magenta))

  (defun post-command-pulse ()
    "Run `pulsar-pulse-line' for `pulsar-pulse-functions'."
    (when (or (memq this-command pulse-functions)
              (memq real-this-command pulse-functions))
      (pulse-line)))


  (add-hook 'occur-mode-find-occurrence-hook #'pulse-line)

  (add-hook 'post-command-hook #'post-command-pulse nil)





#+end_src

*** Expand selection and count words

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el



  (global-set-key (kbd "C-o") 'expand-selection)

  (global-set-key (kbd "C-=") 'count-words)

#+end_src

*** Capitalization and escape quit

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (global-set-key (kbd "M-l") 'downcase-dwim)
  (global-set-key (kbd "M-c") 'capitalize-dwim)
  (global-set-key (kbd "M-u") 'upcase-dwim)
  (global-set-key (kbd "M-c") 'capitalize-dwim)


  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)



#+end_src



** Org-mode

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (setq org-src-fontify-natively t)

  (setq org-directory "~/org-mode/")


  (add-hook 'org-agenda-finalize-hook #'org-modern-agenda)

  (setq org-modern-progress nil
        org-modern-todo nil
        org-modern-block nil)

  (setq org-todo-keywords '((sequence "todo(t)" "finish(f)" "progress(p)" "|" "done(d)" )
                            (sequence "meeting(m)" "rendezvous(r)" "appointment(a)" "next(n)" "|" "cancelled(c)" )
                            (sequence "idea(i)" "review(q)" "|"  "waiting(w)" "inactive(o)")))

  ;; custom agenda veiw


  (defun set-org-defiles ()
    (let ((project-files
           (mapcar
            (lambda (f) (concat
                         org-directory f))
            (seq-filter
             (lambda (f) (not (member f '("." ".."))))
             (directory-files org-directory))
            )))
      (setq org-agenda-files
            `( ,@project-files))
      (setq org-refile-targets
            `(,@(mapcar
                 (lambda (f) `(,f . (:maxlevel . 4)))
                 project-files)
              ,@(mapcar
                 (lambda (f) `(,f . (:tag . "refile")))
                 project-files)))))

  (set-org-defiles)

  (setq org-agenda-files `(,org-directory ,(concat org-directory "capture/")))

  ;; https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html
  (defun air-org-skip-subtree-if-habit ()
    "skip an agenda entry if it has a style property equal to \"habit\"."
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-entry-get nil "style") "habit")
          subtree-end
        nil)))

  (defun air-org-skip-subtree-if-priority (priority)
    "skip an agenda subtree if it has a priority of priority.

    priority may be one of the characters ?a, ?b, or ?c."
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-value (* 1000 (- org-lowest-priority priority)))
          (pri-current (org-get-priority (thing-at-point 'line t))))
      (if (= pri-value pri-current)
          subtree-end
        nil)))

  (setq org-agenda-custom-commands
        '(("d" "agenda and all todos"
           ((tags "priority=\"a\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "high-priority unfinished tasks:")))
            (agenda "" ((org-agenda-ndays 1)))
            (alltodo ""
                     ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                     (air-org-skip-subtree-if-priority ?a)
                                                     (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "all normal priority tasks:"))))
           )))
  (setq org-agenda-ndays 1
        org-agenda-start-on-weekday 1
        org-agenda-skip-scheduled-if-done t)


  (setq org-capture-templates
        '(("r" "rendezvous" entry
           (file "capture/rendezvous.org")
           "* rendezvous %^{form: |meeting|appointment|casual|other} with %^{with}  \n scheduled: %^t\n\n %^{description}"
           :empty-lines 1
           :immediate-finish 1)
          ("e" "email note" entry
           (file+headline "capture/tasks.org" "tasks to be reviewed")
           "* maybe %:subject :mail:\n :end:\n\n %a\n%i%?"
           :empty-lines 1)
          ("i" "idea" entry
           (file "ideas.org")
           "* %^{status |inactive|todo|review} %^{idea}\n %?"
           :empty-lines 1)
          ("t" "task" entry
           (file "tasks.org")
           "* todo %^{priority| |[#a]|[#b]|[#c]} %^{task}\n scheduled: %^t \n %?"
           :empty-lines 1)
          ("n" "task without time" entry
           (file "tasks.org")
           "* todo %^{priority| |[#a]|[#b]|[#c]} %^{task}\n %?"
           :empty-lines 1)
          ("q" "quicktask" entry
           (file "tasks.org")
           "* todo %^{priority| |[#a]|[#b]|[#c]} %^{task}\n scheduled: %^t \n\n %^{descrition}"
           :empty-lines 1
           :immediate-finish 1)))


  (setq org-capture-templates-contexts
        '(("e" ((in-mode . "gnus-article-mode")
                (in-mode . "gnus-summary-mode")
                (in-mode . "message-mode")))))


  (global-set-key (kbd "C-c c") #'org-capture)

  (global-set-key (kbd "C-c a ") 'org-agenda)
  (global-set-key (kbd "C-c s") (lambda()
                                  (interactive)
                                  (find-file (read-file-name "Pick the org file " "~/org-mode/"))))

  (setq org-goto-interface 'outline-path-completion)
  (setq org-outline-path-complete-in-steps nil)


#+end_src




