#+TITLE: Pranshu's emacs configuration

# add org shortcuts
* How to install
Just edit the settings.el file

* Information
** Packages to install

None!

** Key bindings

*** main mode map



* Code

** Early init
This is full of performance optimizations and major screen changing
operations.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
    ;; -*- lexical-binding: t; -*- Pranshu's emacs configuration

    ;; When to activate the garbage cleaner (setq gc-cons-threshold (*
    (setq gc-cons-threshold (* 100 1024 1024))
    (setq inhibit-startup-message t)

    ;; Screen changes to make emacs look more minimal (menu-bar-mode -1)
    (toggle-scroll-bar -1)
    (tool-bar-mode -1)
    (set-fringe-mode 33)
    (menu-bar-mode -1)

    ;; thanks to purcell's no-littering package

    (unless (file-directory-p "~/emacs-var/")
      (make-directory "~/emacs-var/"))

    (setq abbrev-file-name                 (concat user-emacs-directory "etc/" "abbrev.el"))
    (setq auto-insert-directory            (concat user-emacs-directory "etc/"  "auto-insert/"))
    (setq auto-save-list-file-prefix       "~/emacs-var/auto-save/sessions/")
    (setq backup-directory-alist           (list (cons "." "~/emacs-var/backup/")))
    (setq bookmark-default-file            "~/emacs-var/bookmark-default.el")
    (setq calc-settings-file               (concat user-emacs-directory "etc/"  "calc-settings.el"))
    (eval-after-load 'desktop
      '(make-directory "~/emacs-var/desktop/" t))

    (setq desktop-dirname                  "~/emacs-var/desktop/")
    (setq desktop-path                     (list desktop-dirname))
    (setq diary-file                       "~/emacs-var/diary")
    (setq ecomplete-database-file          "~/emacs-var/ecomplete-database.el")
    (setq ede-project-placeholder-cache-file "~/emacs-var/ede-projects.el")
    (eval-after-load 'erc
      '(make-directory "~/emacs-var/erc/dcc/" t ))
    (setq erc-dcc-get-default-directory    "~/emacs-var/erc/dcc/")
    (setq erc-log-channels-directory       "~/emacs-var/erc/log-channels/")
    (eval-after-load 'eshell
      '(make-directory (concat user-emacs-directory "etc/"  "eshell/") t))

    (setq eshell-aliases-file              (concat user-emacs-directory "etc/"  "eshell/aliases"))
    (setq eshell-rc-script                 (concat user-emacs-directory "etc/"  "eshell/rc"))
    (setq eshell-login-script              (concat user-emacs-directory "etc/"  "eshell/login"))
    (setq eshell-directory-name            "~/emacs-var/eshell/")
    (setq eudc-options-file                (concat user-emacs-directory "etc/"  "eudc-options.el"))
    (eval-after-load 'eww
      '(make-directory "~/emacs-var/eww/" t))
    (setq eww-bookmarks-directory          "~/emacs-var/eww/")
    (setq filesets-menu-cache-file         "~/emacs-var/filesets-menu-cache.el")
    (setq gamegrid-user-score-file-directory "~/emacs-var/gamegrid-user-score/")
    (eval-after-load 'gnus
      '(make-directory "~/emacs-var/gnus/dribble/" t))
    (setq gnus-dribble-directory           "~/emacs-var/gnus/dribble/")
    (setq gnus-init-file                   (concat user-emacs-directory "etc/"  "gnus/init.el"))
    (setq ido-save-directory-list-file     "~/emacs-var/ido-save-directory-list.el")
    (setq image-dired-db-file              "~/emacs-var/image-dired/db.el")
    (setq image-dired-dir                  "~/emacs-var/image-dired/")
    (setq image-dired-gallery-dir          "~/emacs-var/image-dired/gallery/")
    (setq image-dired-temp-image-file      "~/emacs-var/image-dired/temp-image")
    (setq image-dired-temp-rotate-image-file "~/emacs-var/image-dired/temp-rotate-image")
    (setq kkc-init-file-name               "~/emacs-var/kkc-init.el")
    (setq multisession-directory           "~/emacs-var/multisession/")
    (eval-after-load 'newsticker
      '(make-directory "~/emacs-var/newsticker/" t))
    (setq newsticker-cache-filename        "~/emacs-var/newsticker/cache.el")
    (setq newsticker-dir                   "~/emacs-var/newsticker/data/")
    (setq nsm-settings-file                "~/emacs-var/nsm-settings.el")
    (eval-after-load 'org
      '(make-directory "~/emacs-var/org/" t))

  (setq doc-view-cache-directory "~/emacs-var/dov-veiw/")
  
    ;; (eval-after-load 'remember
    ;;  '(make-directory "~/emacs-var/org/" t))
    (setq org-clock-persist-file           "~/emacs-var/org/clock-persist.el")
    (setq org-id-locations-file            "~/emacs-var/org/id-locations.el")
    (setq org-persist-directory            "~/emacs-var/org/persist/")
    (setq org-publish-timestamp-directory  "~/emacs-var/org/timestamps/")
    (setq project-list-file                "~/emacs-var/project-list.el")
    (setq quickurl-url-file                "~/emacs-var/quickurl-url.el")
    (setq rcirc-log-directory              "~/emacs-var/rcirc-log/")
    (setq recentf-save-file                "~/emacs-var/recentf-save.el")
    ;; (setq remember-data-file               "~/emacs-var/remember/data")
    ;; (setq remember-data-directory          "~/emacs-var/remember/data.d/")
    (setq save-place-file                  "~/emacs-var/save-place.el")
    (setq savehist-file                    "~/emacs-var/savehist.el")
    (setq srecode-map-save-file            "~/emacs-var/srecode-map.el")
    (setq semanticdb-default-save-directory "~/emacs-var/semantic/")
    (eval-after-load 'shadowfile
      '(make-directory "~/emacs-var/shadow/" t))
    (setq shadow-info-file                 "~/emacs-var/shadow/info.el")
    (setq shadow-todo-file                 "~/emacs-var/shadow/todo.el")
    (setq shared-game-score-directory      "~/emacs-var/shared-game-score/")
    (setq timeclock-file                   "~/emacs-var/timeclock")
    (setq tramp-auto-save-directory        "~/emacs-var/tramp/auto-save/")
    (setq tramp-persistency-file-name      "~/emacs-var/tramp/persistency.el")
    (setq type-break-file-name             "~/emacs-var/type-break.el")
    (setq url-cache-directory              "~/emacs-var/url/cache/")
    (setq url-configuration-directory      "~/emacs-var/url/")
    (setq url-cookie-file                  "~/emacs-var/url/cookies.el")
    (setq url-history-file                 "~/emacs-var/url/history.el")


    (defvar pranshu-edit-mode-map (make-sparse-keymap)
      "The main keymap")



#+end_src



** Main path and font information change when changing machines

#+begin_src emacs-lisp :tangle ~/.emacs.d/settings.el
      ;;---------------------------------------------------------------------------
      ;;---------------------------------------------------------------------------

  (setq gnusmailpath "~/GnusMail") ; Where the GnusMail shoud go.
  (add-to-list 'exec-path "C:/stuff/hunspell/bin") ; Spellchecker path only needed for windows
  (setq inferior-lisp-program "sbcl")


  (setq norm-font "Hack")
  (setq doc-view-resolution 350) ;; dpi
      (setq norm-font-height 18)

      (setq send-mail-function 'smtpmail-send-it)
    (setq message-send-mail-function 'smtpmail-send-it)
      (setq smtpmail-smtp-server "smtp.autistici.org")
      (setq smtpmail-smtp-service 587)
      (setq message-send-mail-function 'smtpmail-send-it)
      (setq send-mail-function 'smtpmail-send-it)

      (setq mail-sources '((pop :server "mail.autistici.org" :user ""
                                :password "" )))

      (setq user-mail-address "" user-full-name "Pranshu Sharma")


  (defvar qwerty-to-kmap
      '(("." . ".")
        ("," . ",")
        ("'" . "'")
        (";" . ";")
        ("/" . "/")
        ("[" . "[")
        ("]" . "]")
        ("=" . "=")
        ("-" . "-")
        ("a" . "a")
        ("b" . "b")
        ("c" . "c")
        ("d" . "d")
        ("e" . "e")
        ("f" . "f")
        ("g" . "g")
        ("h" . "h")
        ("i" . "i")
        ("j" . "j")
        ("k" . "k")
        ("l" . "l")
        ("n" . "n")
        ("o" . "o")
        ("p" . "p")
        ("q" . "q")
        ("r" . "r")
        ("s" . "s")
        ("t" . "t")
        ("u" . "u")
        ("v" . "v")
        ("w" . "w")
        ("x" . "x")
        ("y" . "y")
        ("z" . "z"))
      )


      ;;---------------------------------------------------------------------------
      ;;---------------------------------------------------------------------------

#+end_src

*** If windows is being used

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  ;; if on windows go over this (when (eq system-type 'windows-nt)
  (setq w32-allow-system-shell t)
  (setq ispell-program-name "hunspell")
                                          ;(locate-file "hunspell" exec-path exec-suffixes 'file-executable-p)

  (setq save-interprogram-paste-before-kill 1)

  ;; make PC keyboard's Win key or other to type Super or Hyper, for emacs running on Windows.
  (setq w32-pass-lwindow-to-system nil)
  (setq w32-lwindow-modifier 'super) ; Left Windows key

  (setq w32-pass-rwindow-to-system nil)
  (setq w32-rwindow-modifier 'super) ; Right Windows key

  (setq w32-pass-apps-to-system nil)
  (setq w32-apps-modifier 'hyper) ; Menu/App key
#+end_src


** Options to change

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (if (file-exists-p "~/.emacs.d/settings.elc")
      (load-file "~/.emacs.d/settings.elc")
    (load-file "~/.emacs.d/settings.el"))


  (defun layout-check (Charstr)
    "Return the corresponding char Charstr according to
  `xah-fly--current-layout-kmap'. Charstr must be a string of single
  char. If more than 1 char, return it unchanged.
  Version: 2020-04-18"
    (interactive)
    (if (> (length Charstr) 1)
        Charstr
      (let (($result (assoc Charstr qwerty-to-kmap)))
        (if $result (cdr $result) Charstr ))))

  (defmacro pranshu-define-key (KeymapName KeyCmdAlist &optional DirectQ)
    (let (($keymapName 'keymap-name))
      `(let ((,$keymapName , KeymapName))
         ,@(mapcar
            (lambda ($pair)
              `(define-key
                 ,$keymapName
                 (kbd (,(if DirectQ #'identity #'layout-check) ,(car $pair)))
                 ,(list 'quote (cdr $pair))))
            (cadr KeyCmdAlist)))))


#+end_src



** Functions

*** Writing functions



=C-c 4= flyspell-mode =C-c 5= toggle modeline =C-c 6= center text =C-c
7= visual fill column mode =C-c 8= center text and add flyspell and
remove modeline =C-c 9= turn visusal-fill-column and flyspell off and
add modeline

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (setq sentence-end-double-space nil )


  
  
  (defun toggle-mode-line()
    (interactive)
    (if mode-line-format (setq mode-line-format nil)
      (progn
        (setq mode-line-format (default-value
                                 'mode-line-format))
        (force-mode-line-update) (redraw-display) ) ))

  (defun center-text-toggle() (interactive) (if (car
                                                 (window-margins))
                                                (progn
                                                  (automargin-mode -1)
                                                  (set-window-margins nil nil nil))
                                              (progn
                                                (automargin-mode)
                                                (run-hooks 'window-configuration-change-hook)) ) )

  (defun center-text-flyspell() (interactive) (automargin-mode)
         (flyspell-mode t) (setq mode-line-format nil))

  (defun set-colum-to-default() (interactive) (automargin-mode -1)
         (set-window-margins nil nil nil) (flyspell-mode-off) (setq
                                                               mode-line-format (default-value 'mode-line-format))
         (force-mode-line-update) (redraw-display))

#+end_src

**** Center text

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (defcustom automargin-target-width 98 "width of the margined
      window")


  (define-minor-mode automargin-mode "automatically add margins to
    windows"
    :global nil
    (if automargin-mode
        (add-hook
         'window-configuration-change-hook 'automargin-function nil t)


      (remove-hook 'window-configuration-change-hook 'automargin-function
                   t)))

  (defun automargin--window-width (&optional window) (let ((margins
                                                            (window-margins window))
                                                           (width (window-width window)))
                                                       (+ width
                                                          (or (car margins) 0) (or (cdr margins) 0))))


  (defun automargin-function ()
    (interactive)
    (let*
        (
         (automargin-margin
          (/ (- (frame-width) automargin-target-width)
             2))
         (automargin-margin
          (if
              (< automargin-margin 0) 0
            automargin-margin)))
      (dolist (window (window-list))
        (let ((margin
               (if (= (frame-width) (automargin--window-width window))
                   automargin-margin 0)))
          (set-window-margins window margin
                              margin)))

      (set-fill-column automargin-target-width)))

  ;;(set-window-margins nil nil nil) to reverse

#+end_src

*** Quicknote

Usefull for doing something while writing notes or todos about it or
something.  By pranshu fully.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (setq q-path nil)
  (setq b-name nil)


  (defun setstuff (&optional clear-stuff)
    "Setting the path if one is not already set or is."
    (interactive)
    (cond
     ((eq clear-stuff 1)
      (progn (setq q-path nil b-name nil) (message "Cleared.")))
     ((eq
       clear-stuff 2)
      (setq q-path (expand-file-name (read-file-name
                                      "Select file:"))))
     (t (if (eq major-mode 'dired-mode)
            (progn (setq
                    q-path (dired-get-filename))
                   (setq b-name nil))
          (progn (setq
                  b-name (buffer-name))
                 (setq q-path (buffer-file-name)) (if q-path
                                                      (message "Quicknote file set: %S" b-name)
                                                    (progn (setq b-name nil)
                                                           (message "File must have a path."))))))))

  (defun quicknote() "Opens the file set by (setstuff) in a new window
        with a certin oriantation."
         (interactive) ;; Checking is the window is already open
         (if q-path
             (progn
               (setq b-name
                     (find-file-noselect q-path))
               (if (get-buffer-window b-name)
                   (delete-window (get-buffer-window b-name))
                 (progn ;;If something happen to the buffer
                   (if
                       (or (window-in-direction 'above)
                           (window-in-direction 'below))
                       (split-window-right)
                     (split-window-below))
                   (other-window 1) (switch-to-buffer
                                     b-name))))
           (message "Set the path.")))

#+end_src

*** Expand region

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


  (defun select-symbol()
    "Selects the current symbol"
    (interactive)
    (skip-syntax-forward "'")
    (skip-syntax-forward "_w")
    (push-mark (point) t t)
    (skip-syntax-backward "_w")
    (skip-syntax-backward "'"))

  (defun select-string()
    "Selecting inside a string including the string itself"
    (interactive)
    (goto-char (nth 8 (syntax-ppss)))
    (set-mark (point))
    (forward-sexp)
    )

  ;; to check if point is on the paren
  ;; (looking-at "\\s(")
  ;; (looking-at "\\s)")

  (defun looking-at-forward-paren()
    (interactive)
    (set-mark (point))
    (forward-list))

  (defun looking-at-backward-paren()
    (interactive)
    (set-mark (point))
    (forward-char)
    (backward-list))

  (defun highlight-paren-block()
    (interactive)
    (goto-char (nth 1 (syntax-ppss)))
    (set-mark (point))
    (forward-list)
    )

  (defun highlight-paren-block()
    (interactive)
    (goto-char (nth 1 (syntax-ppss)))
    (set-mark (point))
    (forward-list)
    )

  (defun expand-selection()
    (interactive)
    (if (use-region-p)
        (if (nth 3 (syntax-ppss))  
            (select-string)
          (when (> (car (syntax-ppss)) 0)
            (highlight-paren-block)))
      (cond
       ((looking-at "\\s(")
        (looking-at-forward-paren))
       ((looking-at "\\s)")
        (looking-at-backward-paren))
       ((or
         (looking-at "\\s_\\|\\sw")
         (looking-back "\\s_\\|\\sw" (line-beginning-position)))
        (select-symbol))
       ((nth 3 (syntax-ppss))
        (select-string))
       ((> (car (syntax-ppss)) 0)
        (highlight-paren-block)))))


  ;; If inside quotes (nth 3 (syntax-ppss))
  ;; to check if point is inside pairs ( (car (syntax-ppss)) 0)



#+end_src

*** xah-add-space-after-comma

Credits to Xah Lee

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (defun xah-add-space-after-comma ()
    "Add a space after comma of current block or selection.
    and highlight changes it made.
    Version 2022-01-20"
    (interactive)
    (let ($p1 $p2)
      (if (region-active-p)
          (progn
            (setq $p1 (region-beginning) $p2 (region-end)))
        (progn
          (save-excursion
            (if (re-search-backward "\n[ \t]*\n" nil "move")
                (progn (re-search-forward "\n[ \t]*\n")
                       (setq $p1 (point)))
              (setq $p1 (point)))
            (if (re-search-forward "\n[ \t]*\n" nil "move")
                (progn (re-search-backward "\n[ \t]*\n")
                       (setq $p2 (point)))
              (setq $p2 (point))))))
      (save-restriction
        (narrow-to-region $p1 $p2)
        (goto-char (point-min))
        (while
            (re-search-forward ",\\b" nil t)
          (replace-match ", ")))))
#+end_src

*** Toggle line numbers

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (defun toggle-line-numbers ()
    (interactive)
    (if (bound-and-true-p display-line-numbers-mode)
        (progn
          (set-window-fringes (selected-window) 33 0)
          (display-line-numbers-mode -1)
          (remove-hook 'prog-mode-hook 'display-line-numbers-mode))
      (progn
        (set-window-fringes (selected-window) 15 0)
        (display-line-numbers-mode 1)
        (add-hook 'prog-mode-hook 'display-line-numbers-mode))))

#+end_src

*** file-name to clipboard

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (defun prelude-copy-file-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the clipboard." filename))))

#+end_src

*** Search line

Get all the lines of a minibuffer in a list
(buffer-substring (line-beginning-position 3 ) (line-end-position 3)) to search all the lines


#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


      ;; try to get rid of the buffer end thing
      (defun pranshu-line-search()
        (interactive)
        "search lines for text"
        (let* ((thing nil)
               (total-lines (count-lines (point-min) (point-max)))
               (buffer-end (- (count-lines (point-min) (point-max)) (line-number-at-pos) -1))
               (buffer-begining (- buffer-end total-lines))
               (total-lines (- total-lines 2)))
          (dotimes (number total-lines ) 
            (setq thing (cons (cons (replace-regexp-in-string "^ +" "" (buffer-substring (line-beginning-position buffer-begining) (line-end-position buffer-begining))) number) thing))
            (setq buffer-begining (+ 1 buffer-begining))
            )
          (goto-line (cdr (assoc (completing-read "Line: " thing nil t) thing))))

        nil

        )



#+end_src


** Emacs settings

*** Font nonsense

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (set-face-attribute 'fixed-pitch nil :font (format "%s-%d" norm-font norm-font-height))

  (set-face-attribute 'default nil :font (format "%s-%d" norm-font norm-font-height))
#+end_src

*** History insecurities

I do not like the idea of things that have the potential to grow infinitively in a finite world.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (setq undo-limit 800000) ; the undo limit

  (setq eshell-save-history-on-exit nil) ; why not

  (setq eshell-buffer-maximum-lines 512) ; to save the 

#+end_src

*** Changing emacs behavior

Some default features in emacs that I find annoying and enabling some that are good
for my use case.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (defalias 'yes-or-no-p 'y-or-n-p) ;; y and n instead of yes and no

  (auto-save-mode -1) ; annoying popus

  (setq auto-save-default nil) ; The auto save #xyz# files

  (setq make-backup-files nil)

  (column-number-mode 1)

  (global-auto-revert-mode 1) ; If code is changed by an other application

  (global-visual-line-mode)

  (delete-selection-mode 1) ; overwriting the current region when typing in one.

  (global-so-long-mode 1)



#+end_src

*** Indentaton

I prefer tabs, but emacs uses a mix of tabs as spaces which is a worse then spaces.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (setq-default tab-always-indent t) ; got hippie expand for completion
  (setq-default tab-first-completion 'word-or-paren-or-punct)
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil)

#+end_src

*** Whitespace control

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (add-hook 'before-save-hook 'clean-when-prog)
  (defun clean-when-prog ()(when (derived-mode-p 'prog-mode)
                             (whitespace-cleanup)))

#+end_src

*** utf, large file

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (set-default-coding-systems 'utf-8)
  (setq visible-bell 1)
  (setq large-file-warning-threshold 100000000)


  (defun save-all-unsaved ()
    (interactive)
    (save-some-buffers t ))

 




#+end_src


** Themeing

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


  (require-theme 'modus-themes)


  (setq modus-themes-intense-mouseovers nil)
  ;;   (setq  modus-themes-mode-line '())
  (setq  modus-themes-mode-line '(borderless)) 
  (setq  modus-themes-subtle-line-numbers t)
  (setq  modus-themes-links '(neutral-underline))
  (setq  modus-themes-region '(bg-only no-extend))

  (setq  modus-themes-headings
         '((0 . (variable-pitch monochrome light (height 2.2)))
           (1 . (variable-pitch light (height 1.6)))
           (2 . (variable-pitch light (height 1.4)))
           (3 . (variable-pitch regular (height 1.3)))
           (4 . (rainbow regular (height 1.2)))
           (5 . (rainbow (height 1.1)))
           (t . (variable-pitch rainbow extrabold)))
         )


  (modus-themes-load-themes)
  (modus-themes-load-vivendi)




#+end_src


** Tools

*** Programming modes 
When adding html mode add the keybinding thing

**** Lisp mode

Good old inf lisp. Lots of people are slime advocates but the
complication is not worth the extra feauteres C-c q to compile current defun


#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


  (setq inferior-lisp-prompt "^\\(->\\|<[0-9]*>:\\) *")



  (defun pranshu-lisp-eval-defun-and-go()
    (interactive)
    (if (region-active-p)
        (lisp-eval-region-and-go)
      (lisp-eval-defun-and-go)))

  (pranshu-define-key
   (define-prefix-command 'pranshu-inf-lisp-mode-map)
   '(("a" . pranshu-lisp-eval-defun-and-go)
     ("j" . lisp-load-file)
     ("k" . lisp-compile-defun-and-go)
     ("l" . lisp-compile-file)
   ))

  (add-hook 'lisp-mode-hook #'(lambda()
                          (pranshu-define-key
                           pranshu-edit-mode-map
                           '(("5" . pranshu-inf-lisp-mode-map)
                           ))))



#+end_src


*** latex
No other decent alternative except plain text

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

    (defun reload-pdf ()
      (interactive
      (let*((pdf-file (concat (substring buffer-file-name 0 -4) ".pdf"))
            (cmd (format "pdflatex %s" buffer-file-name)))

        (split-window-vertically)
        (shell-command cmd)
        (delete-other-windows)
        (split-window-horizontally)
        (other-window 1)
        (find-file pdf-file)
        ;; (setq q-path (buffer-file-name))
        )))


      (add-hook 'latex-mode-hook #'(lambda()
                            (pranshu-define-key
                             pranshu-edit-mode-map
                             '(("5" . reload-pdf)
                             ))
                            (setq abbrev-mode t)))



#+end_src



*** Dired

The emacs file manager. I use ls-lisp instead of the systems ls for consitancy across multiple systems.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (require 'dired)
  (require 'ls-lisp)

  (setq ls-lisp-dirs-first t) ; directories first
  (setq ls-lisp-use-insert-directory-program nil) ; do it your self you baffon
  (setq dired-dwim-target t) ; with two dired windows open
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)

  (setq delete-by-moving-to-trash t) ; thinking about what you are doing; hell nah


  (defun dired-mode-setup ()
    "hook for dired mode"
    (dired-hide-details-mode 1))
  (add-hook 'dired-mode-hook 'dired-mode-setup) ; details are distracting

#+end_src




*** Flyspell

I use hunspell because flyspell does not work in windows

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (require 'flyspell)
  (require 'ispell)
  (setq flyspell-issue-message-flag nil)
  (define-key flyspell-mode-map [down-mouse-3] 'flyspell-correct-word)
  (global-set-key (kbd "C-j") 'ispell-word)
  (setq  ispell-dictionary "english")
  (setq   spell-local-dictionary-alist
          '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))

                                          ;(("en_US" ,(concat user-emacs-directory "en_US.aff" )))

#+end_src


*** Eshell

A prompt with only the previous directory and some aliases.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (setq eshell-prompt-function
        (lambda ()
          (concat (car (last (split-string (eshell/pwd) "/"))) " $ ")))

  (defalias 'open 'find-file)
  (defalias 'gs 'magit-status-here)
  (defalias 'd 'dired)
  (defalias 'openo 'find-file-other-window)

  (with-eval-after-load 'eshell  '(lambda()         
                                    (add-to-list 'eshell-output-filter-functions #'eshell-truncate-buffer)))

#+end_src


**** Eshell toggle

Once upon a time there was a toggle eshell package and it was 300 lines of code and it
basically remade functions emacs already has.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


  (setq eshell-config-done nil)

  (defun eshell-tog()
    "Popups the eshell if one is not already open, will create if it has to"
    (interactive)
    (let ((temp-default-directory nil))
      (if(get-buffer "*eshell*")
          (if (get-buffer-window "*eshell*")
              (delete-window (get-buffer-window "*eshell*"))
            (progn
              (split-window-below)
              (other-window 1)
              (setq temp-default-directory default-directory) 
              (switch-to-buffer "*eshell*")
              (cd temp-default-directory)
              (insert "#")
              (eshell-send-input)
              ))
        (progn
          (split-window-below)
          (setq temp-default-directory default-directory)
          (other-window 1)
          (eshell)
          (message "New eshell buffer.")
          (cd temp-default-directory)          
          ))))



#+end_src



#+end_src


** completion and isearch

Used to use Ido then vertico then ido again and then vertico and now fido and icomplete. Hippe expand started expanding blocks which is unacceptable.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


            (setq icomplete-max-delay-chars 0)
            (setq icomplete-compute-delay 0)
            (setq icomplete-prospects-height 2)
            (setq completion-flex-nospace nil)

            (fido-vertical-mode 1)

            (setq hippie-expand-try-functions-list ;; in case of new featueres
                  '(
                    try-expand-dabbrev
                    try-expand-dabbrev-all-buffers
                    try-expand-dabbrev-from-kill
                    try-complete-lisp-symbol-partially
                    try-complete-lisp-symbol
                    try-complete-file-name-partially
                    try-complete-file-name
                    try-expand-all-abbrevs
                    try-expand-list
                    try-expand-line
                    ))


#+end_src




** networking

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (require 'gnus)
  
  
  (setq gnus-use-trees t) 

  (defun tog-message-mode()
    (interactive)
    (if (eq major-mode 'org-mode)
        (message-mode)
      (org-mode)))

  
 ; (global-set-key (kbd "M-g w") 'eww)
  ;;M-enter to open in a new buffer

  (add-hook 'message-mode-hook #'(lambda ()
                                   (flyspell-mode t)))
  (setq gnus-select-method '(nntp "news.gwene.org"))
  (add-to-list 'gnus-secondary-select-methods
               `(nnml ""
                      (nnml-directory ,gnusmailpath)
                      (nnml-active-file ,(concat gnusmailpath "/active") )))


  (setq gnus-use-article-prefetch 15)

  (setq gnus-asynchronous t)

  (setq gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject)


#+end_src


** Buffer cleaning and window managment


*** Buffer cleaning

Just for peace of mind

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (require 'midnight)
  (global-set-key (kbd "C-x c") 'clean-buffer-list)
  (setq clean-buffer-list-delay-general 1)
  (setq midnight-period 7200)
  (midnight-delay-set 'midnight-delay 1)
  (setq midnight-mode t)
  (define-key global-map (kbd "C-x C-b") 'ibuffer)


#+end_src




*** Narrowing to region

I find this sometimes helpful

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (put 'narrow-to-page 'disabled nil) 

  (put 'narrow-to-region 'disabled nil)

#+end_src


** cusrory, expand region and keybindings 


*** Cursory


#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el


  (setq blink-cursor-mode nil)

  (setq pulse-delay 0.07)

  (tooltip-mode -1)

  (defface pulse-magenta
    '((t :inherit pulse-highlight-start-face :extend t)
      (((class color) (min-colors 88) (background light))
       :background "#ffccff")
      (((class color) (min-colors 88) (background dark))
       :background "#71206a")
      (t :inverse-video t))
    "Alternative magenta face for `pulsar-face'.")


  (defcustom pulse-functions
    '(recenter-top-bottom
      move-to-window-line-top-bottom
      reposition-window
      bookmark-jump
      other-window
      delete-window
      delete-other-windows
      forward-page
      backward-page
      scroll-up-command
      scroll-down-command
      windmove-right
      windmove-left
      windmove-up
      windmove-down
      windmove-swap-states-right
      windmove-swap-states-left
      windmove-swap-states-up
      windmove-swap-states-down
      tab-new
      tab-close
      tab-next
      org-next-visible-heading
      org-previous-visible-heading
      org-forward-heading-same-level
      org-backward-heading-same-level
      outline-backward-same-level
      outline-forward-same-level
      outline-next-visible-heading
      outline-previous-visible-heading
      outline-up-heading
      occu)
    "Functions that `pulsar-pulse-line' after invocation.
                This only takes effect when `pulsar-mode' (buffer-local) or
                `pulsar-global-mode' is enabled."
    :type '(repeat function))

  (defun pulse-line()
    (interactive)
    (pulse-momentary-highlight-one-line nil 'pulse-magenta))

  (defun post-command-pulse ()
    "Run `pulsar-pulse-line' for `pulsar-pulse-functions'."
    (when (or (memq this-command pulse-functions)
              (memq real-this-command pulse-functions))
      (pulse-line)))


  (add-hook 'occur-mode-find-occurrence-hook #'pulse-line)

  (add-hook 'post-command-hook #'post-command-pulse nil)





#+end_src




** Org-mode

*** Orrg agendaand capture

While org mode is great and all I feel like it adds complexity

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  ;;; (require 'org)

  ;; (setq org-src-fontify-natively t)

  ;; (setq org-directory "~/org-mode/")

  ;; (define-key org-mode-map (kbd "C-c [") nil)

  ;; (define-key org-mode-map (kbd "C-c ]") nil)

  ;; (setq org-todo-keywords '((sequence "todo(t)" "finish(f)" "progress(p)" "|" "done(d)" )
  ;;                           (sequence "meeting(m)" "rendezvous(r)" "appointment(a)" "next(n)" "|" "cancelled(c)" )
  ;;                           (sequence "idea(i)" "review(q)" "|"  "waiting(w)" "inactive(o)")))

  ;; ;; custom agenda veiw


  ;; (defun set-org-defiles ()
  ;;   (let ((project-files
  ;;          (mapcar
  ;;           (lambda (f) (concat
  ;;                        org-directory f))
  ;;           (seq-filter
  ;;            (lambda (f) (not (member f '("." ".."))))

  ;;            (directory-files org-directory))
  ;;           )))
  ;;     (setq org-agenda-files
  ;;           `( ,@(mapcar
  ;;                 (lambda (x)  (concat org-directory  x))
  ;;                 (seq-filter
  ;;                  (lambda (f) (and (not (member f '("." "..")))
  ;;                                   (not (file-directory-p f))))
  ;;                  (directory-files org-directory)))
  ;;              ,@(mapcar
  ;;                 (lambda (x)  (concat org-directory "capture/" x))
  ;;                 (seq-filter
  ;;                  (lambda (f) (not (member f '("." ".."))))
  ;;                  (directory-files (concat org-directory "capture/")))
  ;;                 )))
  ;;     (setq org-refile-targets
  ;;           `(,@(mapcar
  ;;                (lambda (f) `(,f . (:maxlevel . 4)))
  ;;                project-files)
  ;;             ,@(mapcar
  ;;                (lambda (f) `(,f . (:tag . "refile")))
  ;;                project-files)))))

  ;; (set-org-defiles)

  ;; (setq org-agenda-files `(,@org-agenda-files
  ;;                          ,@(mapcar
  ;;                             (lambda (x)  (concat org-directory "capture/" x))
  ;;                             (seq-filter
  ;;                              (lambda (f) (not (member f '("." ".."))))
  ;;                              (directory-files (concat org-directory "capture/")))
  ;;                             )))

  ;; ;; https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html
  ;; (defun air-org-skip-subtree-if-habit ()
  ;;   "skip an agenda entry if it has a style property equal to \"habit\"."
  ;;   (let ((subtree-end (save-excursion (org-end-of-subtree t))))
  ;;     (if (string= (org-entry-get nil "style") "habit")
  ;;         subtree-end
  ;;       nil)))

  ;; (defun air-org-skip-subtree-if-priority (priority)
  ;;   "skip an agenda subtree if it has a priority of priority.

  ;;     priority may be one of the characters ?a, ?b, or ?c."
  ;;   (let ((subtree-end (save-excursion (org-end-of-subtree t)))
  ;;         (pri-value (* 1000 (- org-lowest-priority priority)))
  ;;         (pri-current (org-get-priority (thing-at-point 'line t))))
  ;;     (if (= pri-value pri-current)
  ;;         subtree-end
  ;;       nil)))

  ;; (setq org-agenda-custom-commands
  ;;       '(("d" "agenda and all todos"
  ;;          ((tags "priority=\"a\""
  ;;                 ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
  ;;                  (org-agenda-overriding-header "high-priority unfinished tasks:")))
  ;;           (agenda "" ((org-agenda-ndays 1)))
  ;;           (alltodo ""
  ;;                    ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
  ;;                                                    (air-org-skip-subtree-if-priority ?a)
  ;;                                                    (org-agenda-skip-if nil '(scheduled deadline))))
  ;;                     (org-agenda-overriding-header "all normal priority tasks:"))))
  ;;          )))

  ;; (setq org-agenda-ndays 1)
  ;; (setq org-agenda-start-on-weekday 1)
  ;; (setq org-agenda-skip-scheduled-if-done nil)


  ;; (setq org-capture-templates
  ;;       '(("r" "rendezvous" entry
  ;;          (file "capture/rendezvous.org")
  ;;          "* rendezvous %^{form: |meeting|appointment|casual|other} with %^{with}  \n SCHEDULED: %^t\n\n %^{description}"
  ;;          :empty-lines 1
  ;;          :immediate-finish 1)
  ;;         ("e" "email note" entry
  ;;          (file+headline "capture/tasks.org" "tasks to be reviewed")
  ;;          "* maybe %:subject :mail:\n :end:\n\n %a\n%i%?"
  ;;          :empty-lines 1)
  ;;         ("i" "idea" entry
  ;;          (file "ideas.org")
  ;;          "* %^{status |inactive|todo|review} %^{idea}\n %?"
  ;;          :empty-lines 1)
  ;;         ("t" "task" entry
  ;;          (file "tasks.org")
  ;;          "* todo %^{priority| |[#a]|[#b]|[#c]} %^{task}\n SCHEDULED: %^t \n %?"
  ;;          :empty-lines 1)
  ;;         ("n" "task without time" entry
  ;;          (file "tasks.org")
  ;;          "* todo %^{priority| |[#a]|[#b]|[#c]} %^{task}\n %?"
  ;;          :empty-lines 1)
  ;;         ("q" "quicktask" entry
  ;;          (file "tasks.org")
  ;;          "* todo %^{priority| |[#a]|[#b]|[#c]} %^{task}\n SCHEDULED: %^t \n\n %^{descrition}"
  ;;          :empty-lines 1
  ;;          :immediate-finish 1)))


  ;; (setq org-capture-templates-contexts
  ;;       '(("e" ((in-mode . "gnus-article-mode")
  ;;               (in-mode . "gnus-summary-mode")
  ;;               (in-mode . "message-mode")))))


  ;; (defun org-agenda-select-file()
  ;;   (interactive)
  ;;   (find-file (read-file-name "Pick the org file " "~/org-mode/")))

  ;; ;; (setq org-goto-interface 'outline-path-completion)
  ;; ;; (setq org-outline-path-complete-in-steps nil)


#+end_src

*** org stuff

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

  (setq org-src-fontify-natively t)
  
#+end_src


** Pranshu-edit-mode

the crown jwel

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

           ;;
           ;; work in progress

           (global-unset-key (kbd "C-x a"))


           ;;xahlee
           (defvar brackets-char '("“”" "()" "[]" "{}" "<>" "＜＞" "（）" "［］" "｛｝" "⦅⦆" "〚〛" "‹›" "«»" "「」" "〈〉" "《》" "【】" "〔〕"  "『』""❛❜" "❝❞" "⁽⁾" "₍₎"  "⁅⁆" "｟｠")
             "A list of strings, each element is a string of 2 chars, the left bracket and a matching right bracket. Used by `xah-select-text-in-quote' and others.")

           (defconst left-brackets
             (mapcar (lambda (x) (substring x 0 1)) brackets-char))


           (defconst right-brackets
             (mapcar (lambda (x) (substring x 1 2)) brackets-char))


           (defun matching-bracket ()
             (interactive)
             (if (nth 3 (syntax-ppss))
                 (backward-up-list 1 'ESCAPE-STRINGS 'NO-SYNTAX-CROSSING)
               (cond
                ((eq (char-after) ?\") (forward-sexp))
                ((eq (char-before) ?\") (backward-sexp ))
                ((looking-at (regexp-opt left-brackets))
                 (forward-sexp))
                ((looking-back (regexp-opt right-brackets) (max (- (point) 1) 1))
                 (backward-sexp))
                (t (backward-up-list 1 'ESCAPE-STRINGS 'NO-SYNTAX-CROSSING)))))






           (defun copy-line-or-region ()
             (interactive)
             (let ((inhibit-field-text-motion nil))
               (if current-prefix-arg
                   (progn
                     (copy-region-as-kill (point-min) (point-max)))
                 (if (region-active-p)
                     (progn
                       (copy-region-as-kill (region-beginning) (region-end)))
                   (if (eq last-command this-command)
                       (if (eobp)
                           nil
                         (progn
                           (kill-append "\n" nil)
                           (kill-append
                            (buffer-substring-no-properties (line-beginning-position) (line-end-position))
                            nil)
                           (progn
                             (end-of-line)
                             (forward-char))))
                     (if (eobp)
                         (if (eq (char-before) 10 )
                             nil
                           (progn
                             (copy-region-as-kill (line-beginning-position) (line-end-position))
                             (end-of-line)))
                       (progn
                         (copy-region-as-kill (line-beginning-position) (line-end-position))
                         (end-of-line)
                         (forward-char))))))))

           (defun cut-line-or-region()
             (interactive)
             (if current-prefix-arg
                 (progn ; not using kill-region because we don't want to include previous kill
                   (kill-new (buffer-string))
                   (delete-region (point-min) (point-max)))
               (progn (if (region-active-p)
                          (kill-region (region-beginning) (region-end) t)
                        (kill-region (line-beginning-position) (line-beginning-position 2))))))


           (defun pranshu-buffer-begend()
             "If at the begining of buffer, go to end and reverse."
             (interactive)
             (if (eq (point) (point-max))
                 (progn
                   (beginning-of-buffer)
                   (message "Begining of buffer."))
               (progn
                 (end-of-buffer)
                 (message "Buffer end.")))
             (pulse-line))

           ;; (glo)

           ;; (mark-paragraph) to mark the current block


           (defun backward-left-bracket ()
             (interactive)
             (re-search-backward (regexp-opt left-brackets) nil t))

           (defun forward-left-bracket ()
             (interactive)
             (re-search-forward (regexp-opt right-brackets) nil t))

           (defun pranshu-negitive-spacing()
             (interactive)
             (cycle-spacing -1))

           ;; todo indent and bind control to hippie expand

           (defun open-line-below()
             (interactive)
             (end-of-visual-line)
             (newline))

           (defun pranshu-toggle-mark()
             (interactive)
             (if (region-active-p)
                 (deactivate-mark)
               (set-mark (point))))


           ;; parasite of the evil org keys


           (pranshu-define-key
            pranshu-edit-mode-map
            '(
              ("SPC" . leader-key-map)
              ;; repeating command
              ("0" . end-of-visual-line)
              ("w" . pop-global-mark)
              ("1" . delete-other-windows)
              ("7" . previous-buffer)
              ("8" . next-buffer)
              ("u" . backward-word)
              ("2" . split-window-below)
              ("4" . ispell-word)
              ("3" . split-window-right)
              ("9" . beginning-of-visual-line)
              ("e" . backward-kill-word)
              ("r" . delete-word)
              ("a" . pranshu-toggle-mark)
              ("b" . open-line-below)
              ("c" . delete-forward-char)
              ("f" . pranshu-edit-mode)
              ("l" . right-char)
              ("j" . left-char)
              ("i" . previous-line)
              ("k" . next-line)
              ("o" . forward-word)
              ("v" . backward-kill-word) ;; unset make abbrev key kater
              (";" . forward-paragraph)
              ("h" . backward-paragraph)
              ("\\" . pranshu-buffer-begend)
              ;;   ("`" . dired-jump) ;; to review
              ;;   ("z" . isearch)
              ("'" . recenter-top-bottom)
              ("d" . delete-map)
              ("s" . expand-selection)
              ("/" . matching-bracket)
              ("q" . mark-paragraph)
              ;;("Q" . mark-page)
              ("6" . xah-toggle-letter-case)
              ("`" . vss-map)
              ("=" . unexpand-abbrev)
              ("-" . fill-paragraph)
              ("[" . delete-pair)
              ("]" . enlarge-window-horizontally)
              ("5" . yank-pop)
              ("z" . pranshu-kill-ring-save)
              ("p" .  undo)
              ("n" . other-window)
              ("m" . isearch-forward)
              ("t" . copy-line-or-region)
              ("g". yank)
              ("v" . delete-backward-char)
              ("." . forward-left-bracket)
              ("," . backward-left-bracket)
              ("x" . imenu)
              ("y" . open-line)
              ("b" . comment-line) ;; make a comment line or ispell function because you do not use code and ispell and comments at The same time

              ("ESC" . keyboard-escape-quit)))

  (defun xah-toggle-letter-case ()
    "Toggle the letter case of current word or selection.
  Always cycle in this order: Init Caps, ALL CAPS, all lower.

  URL `http://xahlee.info/emacs/emacs/modernization_upcase-word.html'
  Version: 2020-06-26"
    (interactive)
    (let ( (deactivate-mark nil) $p1 $p2)
      (if (region-active-p)
          (setq $p1 (region-beginning) $p2 (region-end))
        (save-excursion
          (skip-chars-backward "[:alpha:]")
          (setq $p1 (point))
          (skip-chars-forward "[:alpha:]")
          (setq $p2 (point))))
      (when (not (eq last-command this-command))
        (put this-command 'state 0))
      (cond
       ((equal 0 (get this-command 'state))
        (upcase-initials-region $p1 $p2)
        (put this-command 'state 1))
       ((equal 1 (get this-command 'state))
        (upcase-region $p1 $p2)
        (put this-command 'state 2))
       ((equal 2 (get this-command 'state))
        (downcase-region $p1 $p2)
        (put this-command 'state 0)))))

  




           (defun pranshu-kill-ring-save()
             (interactive)
             (if (region-active-p)
                 (kill-ring-save (region-beginning) (region-end))
               (kill-ring-save (line-beginning-position) (line-end-position))))


           (pranshu-define-key
            (define-prefix-command 'vss-map)
            '(("j" . set-fill-column)
              ("k" . auto-fill-mode)))

           (pranshu-define-key
            (define-prefix-command 'delete-map)
            '(("d" . pranshu-kill-whole-line)
              ("u" . narrow-to-page)
              ("i" . narrow-to-region)
              ("o" . widen)
              ("j" . kill-paragraph)
              ("k" . kill-line)
              ("l" . pranshu-negitive-spacing)))

           ;; make org goto work



           ;; -------------------------------------------- todo
           ;; add a keybinding for switching buffers

           ;; remove all init .org keybinding

           (pranshu-define-key
            (define-prefix-command 'leader-key-map)
            '((";" . count-words)
              ("a" . file-nav-map)
              ("i" . follow-mode)
              ("f" . switch-to-buffer)
              ("SPC" . pranshu-rectangle) ;; find a way to move the prefix keys
              ("e" . save-all-unsaved)
              ("j" . save-buffer)
              ("g" . pranshu-line-search)
              ("d" . occur)
              ("i" . toggle-line-numbers)
              ("q" . eww)
              ("o" . gnus)
              ("k" . dired-jump)
              ("s" . bookmark-prefix-map)
              ("r" . query-replace)
              ("m" . pranshu-mode-comand)
              ("u" . writing-functions-map)
              ("c" . modus-themes-toggle)
              ("w" . eshell-tog)
              ("p" . setstuff-prefix-map)
              ("'" . quicknote)
              ("b" . compile)
              ("/" . xah-add-space-after-comma)
              )
            )



           (defun pranshu-rectangle()
             (interactive)
             (if (region-active-p)
                 (call-interactively 'string-rectangle)
               (rectangle-mark-mode)))

           (pranshu-define-key
            (define-prefix-command 'bookmark-prefix-map)
            '(("j" . bookmark-set)
              ("k" . bookmark-jump)
              ("l" . list-bookmarks)
              (";" . bookmark-rename)))

           (pranshu-define-key
            (define-prefix-command 'writing-functions-map)
            '(("a" . toggle-mode-line)
              ("s" . center-text-toggle)
              ("d" . center-text-flyspell)
              ("f" . set-colum-to-default)
              ("h" . flyspell-mode)))



           ;; move select page to file editing because it is techniqualy rewriting files



           (pranshu-define-key
            (define-prefix-command 'setstuff-prefix-map)
            ;; current name being hoverd on dired or current filepath of buffer
            '(("j" . setstuff)
              ("k" . (lambda () (interactive) (setstuff 1))) ;; prompt
              ("l" . (lambda () (interactive) (setstuff 2)))) ;; clear
            )


           (defun pranshu-mode-comand()
             (interactive)
             (cond ((eq 'org-mode major-mode)
                    (org-goto))
                   ((eq 'lisp-mode major-mode)
                    (call-interactively 'run-lisp))))

           (defun pranshu-kill-whole-line()
             (interactive)
             (if current-prefix-arg
                 (progn
                   (kill-new (buffer-string))
                   (delete-region (point-min) (point-max)))
               (progn (if (region-active-p)
                          (kill-region (region-beginning) (region-end) t)
                        (kill-region (line-beginning-position) (line-beginning-position 2))))))


           (pranshu-define-key
            (define-prefix-command 'file-nav-map)
            '(("j" . find-file)
              ("k" . find-file-other-window)
              ("l" . revert-buffer)
              ;;("a" . project-prefix-map)
              ))


           (define-minor-mode pranshu-edit-mode()
             "To edit faster if you are not a elite pianist"
             :init-value nil
             :global t
             :keymap pranshu-edit-mode-map
             (setq shift-select-mode nil)
             (if pranshu-edit-mode
                 (setq-default cursor-type 'box)
               (setq-default cursor-type 'bar)
               ))

           (add-hook 'minibuffer-setup-hook (lambda () (pranshu-edit-mode -1)))
           (add-hook 'minibuffer-exit-hook (lambda () (pranshu-edit-mode 1)))


           (global-set-key (kbd "C-SPC") 'pranshu-edit-mode)
           (global-set-key (kbd "<home>") 'pranshu-edit-mode)

           (pranshu-edit-mode)
           (global-set-key (kbd "M-SPC") 'pranshu-edit-mode)


            ;; Org goto
            (require 'org-goto)

        (defun org-goto--set-map ()
        "Set the keymap `org-goto'."
        (setq org-goto-map
          (let ((map (make-sparse-keymap)))
            (let ((cmds '(isearch-forward isearch-backward kill-ring-save set-mark-command
                          mouse-drag-region universal-argument org-occur)))
              (dolist (cmd cmds)
                (substitute-key-definition cmd cmd map global-map)))
            (suppress-keymap map)

            (pranshu-define-key
             map
             '(("a" . org-cycle)
               ("RET" . org-goto-ret)
               ("j" . org-previous-visible-heading)
               (";" . org-next-visible-heading)
               ("k" . outline-backward-same-level)
               ("l" . outline-forward-same-level)
               ))

            map)))

    (electric-pair-mode)

    (global-set-key (kbd "C-l") 'forward-char)
    (global-set-key (kbd "C-k") 'backward-char)
    (global-set-key (kbd "C-j") 'hippie-expand)

#+end_src


